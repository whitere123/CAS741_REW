\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage} 
\usepackage{amsmath}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}

\newcommand{\progname}{SpecSearch}

\begin{document}

\title{Module Interface Specification for \progname}

\author{Robert E. White}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
2018-11-09 & 1.0 & Created the first draft for my MIS presentation. \\ 
2018-11-15 & 1.1 & Updated the presentation draft based on feedback from CAS 
741 class. 
Completed half of the module interface specifications. \\ 
2018-11-20 & 1.2 & Completion of the module interface specifications. 
Completion of section 2. \\
2018-11-22 & 1.3 & Edit of 1.2. First submission. \\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms} \label{abbrev}

See SRS Documentation at \url{https://github.com/whitere123/CAS741_REW}. 

\section*{Abbreviations and Acronyms}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
	\toprule		
	\textbf{symbol} & \textbf{description}\\
	\midrule 
	SRS & System Requirements Specification\\ 
	$:$ & ``Contained in"\\ 
	$\neg$ & Negation\\ 
	$\Rightarrow$ & ``It follows"\\ 
	$cn$ & Elliptic cosine function\\ 
	$sn$ & Elliptic sine function\\ 
	$dn$ & Elliptic delta function \\ 
	NLS & Non-linear Schr\"{o}dinger\\  
	$O(1)$ & First order central numerical differentiation method \\ 
	$O(4)$ & Fourth order central numerical differentiation method \\ 
	$cheb$ & Chebyshev numerical differentiation method\\
	dim(in) & The dimension of item ``in" \\
	$\notin$ & Not an element of\\
	\bottomrule
\end{tabular}\\

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
SpecSearch. It will describe the intended behaviour of the 
access routines in SpecSearch's modules. Mathematical notation 
will be used to explain the external 
behaviour 
of the modules and the relationships between input and output. The MIS is still 
abstract since it does not outline any code. 

SpecSearch is scientific computing software that computes and plots 
the spectrum of a matrix operator from a LAX pair that is compatible 
for solutions of the Non-Linear Schr\"{o}dinger (NLS) equation. 
This spectrum carries useful information regarding the stability 
of solutions to the NLS equation. Physicists are interested in this spectrum 
because 
the NLS equation models physical phenomena; such as rogue waves or 
modulated wave packets. Mathematicans are interested in the analytical 
behaviour of this spectrum. 

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/whitere123/CAS741_REW}.
  
\section{Notation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
complex & $\mathbb{C}$ &any number $x + iy$ with $x \in \mathbb{R}$ , $y \in 
\mathbb{R}$ and $i^{2} = -1$. \\ 
real matrix &$\mathbb{R}^{mxn}$ & An $m$ by $n$ Matrix with real elements.\\ 
complex matrix &$\mathbb{C}^{mxn}$ & An $m$ by $n$ Matrix with complex 
elements.\\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding} & ~ \\
\midrule

\multirow{7}{0.3\textwidth}{Behaviour-Hiding} 
& Input Parameters \\
& Output Format \\
& Spectrum Matrix \\
& Exact Eigenvalue Equations \\
& Spectrum Error Equation \\
& Numerical Parameters \\  
& Control \\ 
\midrule

\multirow{3}{0.3\textwidth}{Software Decision} & {Sequence Data Structure}\\
& Eigenvalue and Eigenvector Solver \\
& Diagonal Matrix Generator\\
& Elliptic Integral\\ 
& Elliptic Functions\\ 
& Plotting \\ 
& Linspace \\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\newpage

\section{MIS of Input Parameters} \label{IPM} 

The secrets of this module are the methods for verifying input and the data 
structure for storing the inputed parameters. 

\subsection{Module} 

InParams

\subsection{Uses}

-

\subsection{Syntax}

\begin{center}
\begin{tabular}{p{3cm} p{3cm} p{3cm} >{\raggedright\arraybackslash}p{7cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \ref{Appendix} 
\\
\hline
Load\_params & $k : \mathbb{R}$ & - & NonNumericalError \\
& $N : \mathbb{N}$ &  &  \\
Verify\_params & - & - & BadkRange, NotNat \\
k & - & $\mathbb{R}$ & - \\
N & - & $\mathbb{N}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

$k : \mathbb{R}$ \\ 
$N : \mathbb{N}$ 

\subsubsection{Environment Variables}

InputParameters: The two values entered by the user $(k,N)$. 

\subsubsection{Assumptions}

\begin{itemize}
	\item Load\_params is called before the values of any state variables are 
	accessed.
	\item The user inputs the environment variables in the following order: 
	$(k,N)$.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent InParams.k():
\begin{itemize}
\item output: $out = k$
\item exception: None
\end{itemize}

\noindent InParams.N():
\begin{itemize}
	\item output: $out = N$
	\item exception: None
\end{itemize}

\noindent Load\_Params():
\begin{itemize}
	\item transition: The data is read sequentially from the command line. The 
	data are seperated by the return key. This data is used to populate the 
	previously mentioned state variables. 
	\item exception: exec:=NonNumericalError if non-numerical data is entered. 
\end{itemize} 

\noindent Verify\_Params():
\begin{itemize}
	\item exception: exc:=
\end{itemize}  

\noindent $\neg (k : [0,1]) \Rightarrow \ $ BadkRange\\
$\neg (N : \mathbb{N}) \Rightarrow \ $ BadNRange

\subsubsection{Local Functions}
None
\newpage

\section{MIS of Output Format} \label{OFM}

The secret of this module is the structure used for storing the output data.

\subsection{Module}

OutForm

\subsection{Uses}

Eigenvalue and Eigenvector solver \ref{SEES}, Spectrum Error Equations 
\ref{MSEE} and Numerical 
Parameters \ref{MNP}. 

\subsection{Syntax} 

\begin{center}
	\begin{tabular}{p{3cm} p{3cm} p{3cm} >{\raggedright\arraybackslash}p{7cm}}
		\toprule
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}  \\
		\hline
		capture & $D :\mathbb{R}^{2n}$ & $Spectral$ & - \\ 
		 & $Er_{j} :\mathbb{R}^{2}$ &  & - \\ 
		 & $V_{j} :\mathbb{C}^{4nx4n}$ &  & - \\ 
		 & $Vl_{j} :\mathbb{R}^{4n}$ & & - \\
		$Spectral_{j}$ & - & $\mathbb{C}^{4n(4n+2)}$ & - \\
		$Spectral_{D}$ & - & $\mathbb{R}^{2n}$ & - \\
		$Er_{j}$ & - & $\mathbb{R}$ & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

The $j$ refers to the $j^{th}$ numerical method; $j : \{ O(1), O(4), cheb \}$. 
\ref{abbrev}

\subsubsection{State Variables}

$Spectral_{j}$ : $\mathbb{C}^{4n(4n+2)}$ \\
$Spectral_{D}: \mathbb{R}^{2n}$ \\
$Er_j : \mathbb{R}^{2}$   

\subsubsection{Environment Variables}

None.

\subsubsection{Assumptions}

\begin{itemize}
	\item Eigenvalue and Eigenvector solver, Spectrum Error Equations and 
	Numerical Parameters 
	are called and their outputs are fed into Outform.capture() 
	before any of the state variables are accessed. 
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent OutForm.$Spectral_{D}$():
\begin{itemize}
	\item output: $out = D$
	\item exception: None
\end{itemize}

\noindent OutForm.$Er_{j}$():
\begin{itemize}
	\item output: $out = Er_{j}$
	\item exception: None
\end{itemize} 

\noindent OutForm.$Spectral_{j}$():
\begin{itemize}
	\item output: $out = Spectral_{j}$
	\item exception: None
\end{itemize}

\noindent capture():
\begin{itemize}
	\item Transition: The data ($D$,$Er_{j}$,$V_{j}$,$Vl_{j}$) will be 
	captured from the other 
	modules and then stored into $Spectral$ for convienience. Spectral is a 
	data 
	structure with four cell components. The first three cells are
	$4n+1$ by $4n$ matrices created as follows: the $4n$ by $1$ vector of 
	eigenvalues, $Vl_j$, will be transposed and turned into the $(4n+1)^{th}$ 
	row 
	of 
	$spectral_{j}$. The previous $4n$ rows of $spectral_{j}$ will be the 
	matrix,$ 
	V_j$, 
	composed 
	of the eigenvectors for the $j$ numerical method. Each column of $V_j$ is 
	an eigenvector from the $j$ numerical method. D will be stored in Spectral 
	as the fourth 
	cell component.  
	\item Exception: None
\end{itemize}  

\subsubsection{Local Functions}

None

\newpage
\section{MIS of Spectrum Matrix} \label{SSM}

The structure of the spectrum matrix, its data entries, how 
it is created, and the numerical method for approximating its 
eigenfunctions are the secrets of this module.  

\subsection{Module}

SpecMat

\subsection{Uses}

This module uses Numerical Parameters \ref{MNP}. 

\subsection{Syntax}

\begin{center}
	\begin{tabular}{p{3cm} p{5cm} p{3cm} >{\raggedright\arraybackslash}p{5cm}}
		\toprule
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		create & $n : \mathbb{N} $ &$SpecMat_{O(1)}$ & - \\ 
		 & $h : \mathbb{R} $& $SpecMat_{O(4)}$ & - \\ 
		 & $elipMAT : \mathbb{R}^{2nx2n} $ &$SpecMat_{Cheb}$ & - \\ 
		 & $k : \mathbb{R} $ & & - \\
		$SpecMat_{O(1)}$ & - & $\mathbb{R}^{4nx4n}$ & - \\
		$SpecMat_{O(4)}$ & - & $\mathbb{R}^{4nx4n}$ & - \\ 
		$SpecMat_{Cheb}$ & - & $\mathbb{R}^{4nx4n}$ & - \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
$SpecMat_{Cheb} : \mathbb{R}^{4nx4n}$\\ 
$SpecMat_{0(4)} : \mathbb{R}^{4nx4n}$\\
$SpecMat_{0(1)} : \mathbb{R}^{4nx4n}$

\subsubsection{Environment Variables}

None. 

\subsubsection{Assumptions}

\begin{itemize}
	\item Numerical parameters is called, its state variables are validated and 
	its state variables are fed into SpecMat.create() before any of SpecMat's 
	state variables are accessed. 
\end{itemize}

\subsubsection{Access Routine Semantics}

SpecMat.$SpecMat_{O(1)}:$
\begin{itemize}
	\item output: out = $SpecMat_{O(1)}:$ 
	\item exception: None 
\end{itemize}

\noindent
SpecMat.$SpecMat_{O(4)}:$
\begin{itemize}
	\item output: out = $SpecMat_{O(4)}:$
	\item exception: None
\end{itemize}

\noindent
SpecMat.SpecFour:
\begin{itemize}
	\item output: out = $SpecMat_{cheb}:$
	\item exception: None
\end{itemize}

\noindent
SpecMat.create():
\begin{itemize}
	\item transition: The data (n,h,elipMAT,k) will be captured from numerical 
	parameters and used to create the spectral matrices. There will be three 
	spectral matrices. Each matrix corresponds to a different 
	numerical 
	algorithm for approximating the eigenfunction derivatives. The top right 
	and 
	bottom left quadrants of the spectral matrices are diagonal matrices with 
	diagonal  
	elements 
	equal to the negative elipdn (or cn) function (\ref{MELF}) evaluated at 
	points in 
	the 
	discretized domain \ref{MNP}. 
	The remaining quadrants of the matrix are equal to $-NUM_{j}$ or $+NUM_{j}$ 
	such that: 
	
\[
NUM_{O(1)}=
\begin{bmatrix}
0 & \frac{n}{2} & 0 & \dots & 0 &-\frac{n}{2}\\
-\frac{n}{2} & 0 & \frac{n}{2} & \ddots & \ddots &0\\
0 & -\frac{n}{2} & \ddots & \ddots & \ddots &0\\
\vdots & \ddots & \ddots & \ddots & \frac{n}{2} &\vdots \\
0 & \ddots & \ddots & -\frac{n}{2} & 0 &\frac{n}{2} \\ 
\frac{n}{2} & 0 & \dots & 0 & -\frac{n}{2} & 0 
\end{bmatrix}
\] 

\[
NUM_{O(6)}=
\begin{bmatrix}
0 & \frac{3n}{4} & -\frac{3n}{20} & \frac{n}{60} &0& \dots&0 & -\frac{n}{60} & 
\frac{3n}{20} & 
-\frac{3n}{4}\\
-\frac{3n}{4} & 0 & \frac{3n}{4} & -\frac{3n}{20} & \frac{n}{60}&0 &\dots&0& 
-\frac{n}{60} & 
\frac{3n}{20}\\
\frac{3n}{20} & -\frac{3n}{4} & \ddots & \ddots & \ddots &\ddots & 
\ddots&\ddots&0 
&-\frac{n}{60}\\
-\frac{n}{60} & \frac{3n}{20} & \ddots & \ddots & \ddots &\ddots & \ddots 
&\ddots &\ddots&0\\ 
0 & -\frac{n}{60} & \ddots & \ddots & \ddots& \ddots& \ddots& \ddots 
&\ddots&\vdots\\
\vdots & \ddots & \ddots & \ddots & \ddots & \ddots& 
\ddots&\ddots&\frac{n}{60}&0\\
0 & \ddots & \ddots & \ddots & \ddots &\ddots & \ddots& \ddots& -\frac{3n}{20} 
& 
\frac{n}{60}\\ 
\frac{n}{60} & 0 & \ddots & \ddots & \ddots & \ddots & \ddots& 
\ddots&\frac{3n}{4}  
&-\frac{3n}{20} 
\\ 
-\frac{3n}{20} & \frac{n}{60} & 0 &\ddots & \ddots & 
 -\frac{n}{60} & \frac{3n}{20} &-\frac{3n}{4} &0 
&\frac{3n}{4}  \\ 
\frac{3n}{4} & -\frac{3n}{20} & \frac{n}{60} & 0 & \dots & 
0 & 
-\frac{n}{60} &\frac{3n}{20} & -\frac{3n}{4} & 0 
\end{bmatrix}
\]  

\[
NUM_{Cheb}=
\begin{bmatrix}
0 & &  &  &   &-\frac{1}{2} cot(\frac{1h}{2})\\
-\frac{1}{2} cot(\frac{1h}{2}) & \ddots & \ddots & \ddots & \ddots   
&\frac{1}{2} cot(\frac{2h}{2})\\
\frac{1}{2} cot(\frac{2h}{2}) & \ddots & \ddots & \ddots & \ddots   
&-\frac{1}{2} cot(\frac{3h}{2})\\
-\frac{1}{2} cot(\frac{3h}{2}) & \ddots & \ddots & \ddots & \ddots   
&\vdots \\
\vdots & \ddots & \ddots & \ddots & \ddots   &\frac{1}{2} cot(\frac{1h}{2})\\
\frac{1}{2} cot(\frac{1h}{2}) &  & &  &    & 0  
\end{bmatrix}
\]  

Therefore the output matrices are: 

 \[
SpecMat_{O(1)}=
\left[ {\begin{array}{cc}
	NUM_{O(1)} & -EllipMat_{O(1)} \\
	-EllipMat_{O(1)} & -NUM_{O(1)} \\
	\end{array} } \right]
\] 

 \[
SpecMat_{O(4)}=
\left[ {\begin{array}{cc}
	NUM_{O(4)} & -D_{O(4)} \\
	-D_{O(4)} & -NUM_{O(4)} \\
	\end{array} } \right]
\] 

 \[
SpecMat_{cheb}=
\left[ {\begin{array}{cc}
	NUM_{cheb} & -D_{cheb} \\
	-D_{cheb} & -NUM_{cheb} \\
	\end{array} } \right]
\] 

	\item exception: None
\end{itemize}

\subsubsection{Local Functions} 

None. 

\newpage

\section{MIS of Exact Eigenvalue Equations} \label{SEE}

The secrets of this module are the analytical expressions for the two purely 
real 
eigenvalues. 

\subsection{Module}

TheorEigenValues

\subsection{Uses}

This module uses input parameters \ref{IPM}. 

\subsection{Syntax}

\begin{center}
	\begin{tabular}{p{3cm} p{3cm} p{3cm} >{\raggedright\arraybackslash}p{7cm}}
		\toprule
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		$\lambda_O1$ & $k : \mathbb{R}$ & $\mathbb{R}$ & - \\
		$\lambda_O2$ & $k : \mathbb{R}$ & $\mathbb{R}$ & - \\ 
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

\begin{itemize}
	\item These are the eigenvalues computed from \citet{SegaletAl}. 
\end{itemize}

\subsubsection{Access Routine Semantics}


$\lambda_O1$:
\begin{itemize}
	\item output: $\frac{1}{2} (1+\sqrt{1-k^{2}})$ 
	\item exception: None
\end{itemize}


\noindent $\lambda_O2$
\begin{itemize} 
	\item output: $\frac{1}{2} (1-\sqrt{1-k^{2}})$ 
	\item exception: None
\end{itemize}

\subsubsection{Local Functions} 

None. 

\newpage

\section{MIS of Spectrum Error Equation} \label{MSEE}

The secret of this module is the equation for error between exact and 
approximated eigenvalues.

\subsection{Module}

ErrCalc

\subsection{Uses}

This module uses Exact Eigenvalue equations \ref{SEE} and Eigenvalue and 
Eigenvector solver 
\ref{SEES}. 

\subsection{Syntax}

\begin{center}
	\begin{tabular}{p{3cm} p{6cm} p{3cm} >{\raggedright\arraybackslash}p{3cm}}
		\toprule
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		$\lambda_O1$ & - & $\mathbb{R}$ & - \\
		$\lambda_O2$ & - & $\mathbb{R}$ & - \\ 
		$\lambda_C1$ & - & $\mathbb{R}$ & - \\
		$\lambda_C2$ & - & $\mathbb{R}$ & - \\
		$Err1$ & $\lambda_O1 : \mathbb{R}$ & $\mathbb{R}$ &- \\
		 & $\lambda_C1 : \mathbb{R}$ &  &- \\
		$Err2$ & $\lambda_C2 : \mathbb{R}$ & $\mathbb{R}$ &- \\
		 & $\lambda_C2 : \mathbb{R}$ &  &- \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

$\lambda_O1 : \mathbb{R}$ \\
$\lambda_O2 : \mathbb{R}$ \\
$\lambda_C1 : \mathbb{R}$ \\ 
$\lambda_C2 : \mathbb{R}$

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}


	None.

\subsubsection{Access Routine Semantics}

$Err1$:
\begin{itemize}
	\item output: $| \lambda_O1 - \lambda_C1| $ 
	\item exception: None
\end{itemize}


\noindent $Err2$
\begin{itemize} 
	\item output: $| \lambda_O2 - \lambda_C2| $ 
	\item exception: None
\end{itemize} 

\noindent $ErrCalc.\lambda_O1$:
\begin{itemize}
	\item output: out = $\lambda_O1$
	\item exception: None 
\end{itemize}

\noindent $ErrCalc.\lambda_O2$:
\begin{itemize}
	\item output: out = $\lambda_O2$
	\item exception: None
\end{itemize}

\noindent $ErrCalc.\lambda_C1$:
\begin{itemize}
	\item output: out = $\lambda_C1$
	\item exception: None
\end{itemize}

\noindent $ErrCalc.\lambda_C2$:
\begin{itemize}
	\item output: out = $\lambda_C2$ 
	\item exception: None
\end{itemize} 

\subsubsection{Local Functions} 

None. 

\newpage 

\section{MIS of Numerical Parameters} \label{MNP}

The secrets of this module are the range of the eigenfunction domain, points in 
the 
periodic domain and equation for the numerical scaling factor that computes 
the 
eigenfunction derivatives. 

\subsection{Module}

Numpars

\subsection{Uses}

This module uses Elliptic Functions \ref{MELF}, Diagonal Matrix \ref{MDM}, 
linspace \ref{MLIN}, Elliptic 
Integral \ref{MEI} and input parameters \ref{IPM}. 

\subsection{Syntax}

\begin{center}
	\begin{tabular}{p{3cm} p{3cm} p{7cm} >{\raggedright\arraybackslash}p{3cm}}
		\toprule
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		CreateVars & $k :\mathbb{R}$ & 
		$xend: \mathbb{R}$ & - \\ 
		  &$N: \mathbb{N}$ & $Domain:\mathbb{R}^{2N}$ &  \\
		  &  & $ellipj: \mathbb{R}^{2N}$ &  \\ 
		  &  & $ellipMAT: \mathbb{R}^{2Nx2N}$ &  \\
		$xend$ & - & $\mathbb{R}$ & - \\
		$Domain$ & - & $\mathbb{R}^{2N}$ &- \\
		$ellipjdn$ & - & $\mathbb{R}^{2N}$ &- \\
		$ellipjMAT$ & - & $\mathbb{R}^{2Nx2N}$ &- \\
		h & - & $\mathbb{R}$ & -\\ 
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
$h :\mathbb{R}$ \\  
$Domain:\mathbb{R}^{2N}$ \\  
$ellipjdn: \mathbb{R}^{2N}$ \\ 
$ellipMAT: \mathbb{R}^{2Nx2N}$ \\  
$xend: \mathbb{R} $

\subsubsection{Environment Variables}

None

\subsubsection{Assumptions}

\begin{itemize}
	\item Input parameters is called before Numerical parameters. 
	\item Input parameters does not throw an exception. 
\end{itemize}

\subsubsection{Access Routine Semantics}


$Numpars.xend$:
\begin{itemize}
	\item output: $xend$ 
	\item exception: None
\end{itemize}


\noindent $Numpars.Domain$
\begin{itemize} 
	\item output: $Domain$ 
	\item exception: None
\end{itemize} 

\noindent $Numpars.ellipjdn$:
\begin{itemize}
	\item output: out = $ellipjdn$
	\item exception: None 
\end{itemize}

\noindent $Numpars.ellipjMAT$:
\begin{itemize}
	\item output: out = $ellipjMAT$
	\item exception: None
\end{itemize}

\noindent $Numpars.h$:
\begin{itemize}
	\item output: out = $h$ 
	\item exception: None
\end{itemize} 

\noindent $Numpars.CreateVars$:
\begin{itemize}
	\item transition: The data $(N,k)$ will be captured from the input 
	parameters module and used to create the state variables. $k$ will be 
	inputted as 
	an argument into the elliptic integral module \ref{MEI}. The resulting 
	integral is 
	equal to $xend$. \\ 
	The domain is created using linspace \ref{MLIN}. The endpoint arguments of 
	linspace 
	are $-xend$ and $xend$, respectively. The distance between partition points 
	in the resulting domain is $h=\frac{xend}{N}$. Ellipjdn is derived by 
	computing the ellipjdn value \ref{MELF} of each point in the Domain. 
	EllipjMAT is a 
	diagonal matrix whose diagonal is Ellipjdn. 
	\item exception: None
\end{itemize} 

\subsubsection{Local Functions} 

None. 

\newpage

\section{MIS of Eigenvalue and Eigenvector Solver} \label{SEES}

The secret of this module is the numerical algorithm for calculating the 
eigenvalues and eigenvectors of an $n$ by $n$ matrix.

\subsection{Module}

eig (\url{https://www.mathworks.com/help/matlab/ref/eig.html})

\subsection{Uses}

This module uses Spectrum Matrix \ref{SSM}. 

\subsection{Syntax}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{4cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} 
		\ref{Appendix} \\
		\hline
		solver & $A : \mathbb{C}^{nxn}$  & 
		$\mathbb{C}^{n}$ x $\mathbb{R}^{nxn}$ & NotsquareMat \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

None.

\subsubsection{Assumptions}

\begin{itemize}
	\item The input is a square matrix. 
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent eig():
\begin{itemize}
	\item output: out:= $\lambda$ and $\bar{v}$ such that:\\
	$A\bar{v} = \lambda \bar{v}$ \\
	$\bar{v} : \mathbb{C}^{n}$ and $\lambda : \mathbb{C}$
	\item exception: exce:= $ \neg (A : \mathbb{C}^{nxn}) \Rightarrow$ 
	NotSquareMatrix 
\end{itemize}

\subsubsection{Local Functions} 

None. 

\newpage

\section{MIS of Diagonal Matrix} \label{MDM}

The secrets of this module are the numerical algorithm for creating an $n$ by 
$n$ diagonal 
matrix from an $n$ by 1 vector and the numerical algorithm for creating an $n$ 
by 1 vector from an $n$ by $n$ diagonal 
matrix. 

\subsection{Module}

diag (\url{https://www.mathworks.com/help/matlab/ref/diag.html})

\subsection{Uses}

This module uses Numerical Parameters \ref{MNP}. 

\subsection{Syntax}

\begin{center}
	\begin{tabular}{p{2cm} p{6cm} p{6cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} 
		\ref{Appendix} \\
		\hline
		solver & $A :$ Diagonal $n$ by $n$ matrix  & $\mathbb{C}^{n}$ & 
		NotDiagMat \\ 
		solver & $v :\mathbb{C}^{n}$  & Diagonal $n$ by $n$ matrix & 
		NotVector \\
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

None.

\subsubsection{Assumptions}

\begin{itemize}
	\item The input is a square matrix or column vector.  
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent diag.solver():
\begin{itemize}
	\item output (if In=$A$): out:= v such that:\\
	$A(j,j) = v(j)$ for j=1,2,...,n \\
	\item exception (if In=$A$): exce:= $A \not\in (Diagonal Matrix) 
	\Rightarrow$ 
	NotDiagonalMatrix 
	\item output (if In=$v$): out:= A such that:\\
	$A(j,j) = v(j)$ for j=1,2,...,n and zero else. \\
	\item exception (if In=$v$): exce:= $v \not\in \mathbb{C}^{n} \Rightarrow$ 
	NotVector 
\end{itemize} 

\subsubsection{Local Functions} 

None. 

\newpage 

\section{MIS of Elliptic Integral} \label{MEI}

The secret of this module is the the numerical algorithm for calculating the 
complete 
elliptic integral for some real constant $k$.

\subsection{Module}

ellipK (\url{https://www.mathworks.com/help/symbolic/elliptick.html})

\subsection{Uses}

This module uses Numerical Parameters \ref{MNP}. 

\subsection{Syntax}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} 
		\ref{Appendix} \\
		\hline
		solver & $k : \mathbb{R}$ & $\mathbb{R}$ & 
		NonNumericalError \\ 
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

None.

\subsubsection{Assumptions}

\begin{itemize}
	\item The user understands the physical context of the number k.  
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent ellipK.solver():
\begin{itemize}
	\item output : \\
	$$ 
	\int_{0}^{\frac{\pi}{2}} \frac{dx}{\sqrt{1-ksin^{2}(x)}}$$ \\
	\item exception : exce:= $\neg(k : \mathbb{R}) \Rightarrow$ 
	NonNumeric
\end{itemize}

\subsubsection{Local Functions} 

None. 

\newpage

\section{MIS of Elliptic Functions} \label{MELF}

The secret of this module is the the numerical algorithm for calculating the 
values of the elliptic functions.

\subsection{Module}

ellipj (\url{https://www.mathworks.com/help/matlab/ref/ellipj.html})

\subsection{Uses}

This module uses Numerical Parameters \ref{MNP}. 

\subsection{Syntax}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} 
		\ref{Appendix}\\
		\hline
		solver & $X : \mathbb{R}^{n}$ & $\mathbb{R}^{3xn}$ & 
		NotVector \\ 
		 & $k : \mathbb{R}$ &  &  \\ 
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

None.

\subsubsection{Assumptions}

None.

\subsubsection{Access Routine Semantics}

\noindent ellipj.solver():
\begin{itemize}
	\item output : $Y: \mathbb{R}^{n}$ such that $Y(1,j)= sn(X(j),k)$, 
	$Y(2,j)=cn(X(j),k)$ and $Y(3,j)=dn(X(j),k)$. See Module link for more 
	detail regarding jacobi ellptic functions sn,dn and cn. 
	\item exception : exce:= $\neg(X : \mathbb{R}^{n}) \Rightarrow$ 
	NotVector
\end{itemize} 

\subsubsection{Local Functions} 

None. 

\newpage 

\section{MIS of Plotting} \label{MPLT} 

The secret of this module is the plotting algorithm. 

\subsection{Module}

plot (\url{https://www.mathworks.com/help/matlab/ref/plot.html})

\subsection{Uses}

This module uses Output \ref{OFM}. 

\subsection{Syntax}

\begin{center}
	\begin{tabular}{p{2cm} p{4cm} p{4cm} p{5cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} 
		\ref{Appendix} \\
		\hline
		plot & $X : \mathbb{R}^{n}$ & graph(Y) & 
		BadVal, DimensionErr \\ 
		& $Y : \mathbb{R}^{n}$ &  &  \\ 
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

None.

\subsubsection{Assumptions}

None.

\subsubsection{Access Routine Semantics}

\noindent plot.plot():
\begin{itemize}
	\item Transition: Plot accepts two vectors as input. A figure is created 
	with the following properties. The domain ranges from the minimum of X to 
	the maximum of X. The range ranges from the minimum of Y to the maximum of 
	Y. The pairs $(X(j),Y(j))$ for $j=1,2,...,n$ are plotted on a figure with 
	respect to the aforementioned axes. 
	\item exception : exce1:= $\neg(X,Y \in \mathbb{C}^{n}) \Rightarrow$ 
	BadVal \\
	exce2:= $\neg (dim(Y) = dim(X)) \Rightarrow$ DimensionErr \\
\end{itemize}

\subsubsection{Local Functions} 

None. 

\newpage 

\section{MIS of Linspace} \label{MLIN}

The secret of this module is the software algorithm for creating a vector with 
equally spaced entries. 

\subsection{Module}

Linspace (\url{https://www.mathworks.com/help/matlab/ref/linspace.html})

\subsection{Uses}

This module uses Numerical Parameters \ref{MNP}. 

\subsection{Syntax}

\begin{center}
	\begin{tabular}{p{2cm} p{6cm} p{6cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} 
		\ref{Appendix}\\
		\hline
		create & $a : \mathbb{R}$ & $\mathbb{R}^{c}$ & 
		NonNumerical \\
		& $b : \mathbb{R}$ &  & notNat \\  
		& $c : \mathbb{N}$ &  &  \\ 
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

None.

\subsubsection{Assumptions}

None.

\subsubsection{Access Routine Semantics}

\noindent linspace.create():
\begin{itemize}
	\item output : $X : \mathbb{R}^{c}$ such that X(1)=a, X(n)=b and 
	$|x(k)-x(k-1)|=\frac{b-a}{n-1}$ for $k \in {2,3,4,..,n}$. 
	\item exception : exce:= $\neg(c \in \mathbb{N}) \Rightarrow$ 
	notNat
	\item exception : exce:= $\neg(a: \mathbb{R}) \Rightarrow$ 
	NonNumericalError 
	\item exception : exce:= $\neg(b: \mathbb{R}) \Rightarrow$ NonNumericalError
\end{itemize}

\subsubsection{Local Functions} 

None. 

\newpage 

\section{MIS of Control} \label{MCON}

The secret of this module is the algorithm that coordinates the overall program 
and 
interaction between modules.

\subsection{Module}

Main

\subsection{Uses}

This module uses Input Parameters, Numerical Parameters, Spectrum Matrix, 
Eigenvalue solver, Spectrum Error , Output and plotting.

\subsection{Syntax}

\begin{center}
	\begin{tabular}{p{2cm} p{6cm} p{6cm} p{3cm}}
		\hline
		\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
		\hline
		main & - & - & - \\ 
		\hline
	\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

None.

\subsubsection{Environment Variables}

None.

\subsubsection{Assumptions}

None.

\subsubsection{Access Routine Semantics}

\noindent main():
\begin{itemize}
	\item transition: This function controls the running of the scientific 
	software. First, input is taken from the user. This input is used to create 
	useful numerical parameters that will drive the rest of the calculations. 
	The input is brought to the numerical parameters module where useful 
	constants, matrices and elliptic function values are calculated. The state 
	variables from Numerical parameters are used as arguments in Spectrum 
	Matrix. The spectrum (eigenvalues) can be calculated once the spectrum 
	matrix is created. These eigenvalues are plotted and their deviation from 
	theoretical values are computed (err modules). 
\end{itemize}

\subsubsection{Local Funtions} 

None. 

\newpage 


\bibliographystyle {plainnat}
\bibliography {../../../ReferenceMaterial/References}

\newpage

\section{Appendix} \label{Appendix}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
	\toprule		
	\textbf{exception name} & \textbf{description}\\
	\midrule 
	NonNumericalError & The input is not a number.\\ 
	BadkRange & The value of k is out of its necessary range.\\ 
	NotsquareMat & The input matrix is not square (or n by n for n: 
	$\mathbb{N}$)\\ 
	NotDiagMat & The input matrix is not diagonal \\ 
	NotVector & The input was not a vector. \\ 
	BadVal & At least one of the vector elements is not a number. \\ 
	NotNat & The input was not a natural number. \\
	\bottomrule
\end{tabular}\\


\end{document}
